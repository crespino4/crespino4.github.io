{"version":3,"file":"static/js/4152.3bca14fa.chunk.js","mappings":"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","sources":["components/home/Home.js"],"sourcesContent":["import React, { useEffect } from 'react';\n\nimport { useSelector } from 'react-redux';\n\n// Services and utilities\nimport { GCloud } from 'services/gcloud';\nimport { logToConsole } from 'components/utils';\n\n// Genesys Spark UI\nimport { GuxCardBeta, GuxInlineAlertBeta, GuxTableBeta, GuxToggle } from 'genesys-spark-components-react';\nimport { registerElements } from 'genesys-spark-components';\nimport 'genesys-spark-components/dist/genesys-webcomponents/genesys-webcomponents.css';\nregisterElements();\n\nimport './Home.css';\n\nconst Home = () => {\n    const [queueList, setQueueList] = React.useState([]);\n    const [configuredMediaTypes, setConfiguredMediaTypes] = React.useState([]);\n    const [relevantMediaTypes, setRelevantMediaTypes] = React.useState([]);\n    const [agentId, setAgentId] = React.useState(undefined);\n    const [exception, setException] = React.useState(undefined);\n\n    const debugMode = useSelector((state) => state.debugMode.value);\n    const supportedMediaTypes = useSelector((state) => state.deploymentProperties.value.supportedMediaTypes);\n\n    /**\n     * GuxToggle click event handler, immediately updating queue joined status\n     * @param {GuxToggleCustomEvent<boolean>} e The event object, also including GuxToggle component reference\n     * @param {string} mediaType The associated media type with the GuxToggle component\n     * @returns \n     */\n    const onToggleClick = (e, mediaType) => {\n        updateQueueStatus(mediaType, e.detail);\n        return;\n    }\n\n    /**\n     * Determines whether a given queue is media type compliant. This check is based upon inspecting queue\n     * name according to a naming convention consisting of different parts. Parts are divided with underscore:\n     * - Part 1: country (code); usually two characters in UPPERcase, but not explicitly enforced\n     * - Part 2: media type, should be a single word\n     * - Part 3: department / topic / queue name; this last part may include underscore characters as well\n     * @param {string} queueName Queue name\n     * @param {array} supportedMediaTypes List of supported (configured) media types\n     * @returns Undefined whenever queue name is not compliant, otherwise the media type itself\n     */\n    const isCompliantMediaTypeQueue = (queueName, supportedMediaTypes) => {\n        const queueNameParts = queueName.split('_');\n        if (queueNameParts.length >= 3) {\n            const queueMediaType = queueNameParts[1].toLowerCase()\n            return (supportedMediaTypes.hasOwnProperty(queueMediaType)) ? queueMediaType : undefined;\n        }\n        return undefined;\n    }\n\n    /**\n     * From two lists (supported media types as configured and the list of agent queues), determine which list of media types\n     * is applicable for this agent. This may be a subset of all supported media types\n     * @param {array} thisQueueList The list of agent queues\n     * @param {array} thisSupportedMediaTypes The list of (configured) supported media types\n     * @returns List of relevant media types for the agent and join status (grouped by media type)\n     */\n    const filterApplicableMediaTypes = (thisQueueList, thisSupportedMediaTypes) => {\n        let mediaTypes = [];\n\n        for (let idx = 0; idx < thisQueueList.length; idx++) {\n            const thisQueueName = thisQueueList[idx].name\n            const thisQueueJoinStatus = thisQueueList[idx].joined\n\n            const compliantMediaType = isCompliantMediaTypeQueue(thisQueueName, thisSupportedMediaTypes);\n            if (compliantMediaType) {\n                const filteredMediaType = mediaTypes.filter(mediaType => {\n                    return mediaType.mediaType == compliantMediaType\n                });\n\n                if (filteredMediaType.length == 0) {\n                    mediaTypes.push(\n                    {   mediaType: compliantMediaType,\n                        label: thisSupportedMediaTypes[compliantMediaType],\n                        joinStatus: thisQueueJoinStatus\n                    });\n                }\n            }\n        }\n\n        return mediaTypes;\n    };\n\n    /**\n     * Update all queues related to given media type with given new queue joined status\n     * @param {string} mediaType The media type to update queue status for\n     * @param {boolean} newStatus The new queue joined status\n     */\n    const updateQueueStatus = async (mediaType, newStatus) => {\n        try {\n            logToConsole(debugMode, `Home:UpdateQueueStatus:Start - [${mediaType}] queues to new status [${newStatus}]`);\n\n            if (agentId) {\n                let newQueueStatusList = [];\n                for (let idx = 0; idx < queueList.length; idx++) {\n                    const thisQueueName = queueList[idx].name;\n                    const thisQueueId = queueList[idx].id;\n    \n                    const compliantMediaType = isCompliantMediaTypeQueue(thisQueueName, configuredMediaTypes);\n                    if (compliantMediaType == mediaType) {\n                        newQueueStatusList.push({\n                                id: thisQueueId,\n                                joined: newStatus\n                        });\n                    }\n                }\n    \n                await GCloud.patchUserQueues(agentId, newQueueStatusList);\n                updateQueueList(newQueueStatusList);\n                logToConsole(debugMode, 'Home:UpdateQueueStatus:End', newQueueStatusList);\n            }\n            else {\n                logToConsole(debugMode, 'Home:UpdateQueueStatus:UnknownAgentId');\n            }\n\n            setException(undefined);\n        }\n        catch (err) {\n            logToConsole(debugMode, 'Home:UpdateQueueStatus:Exception', err);\n            setException(err);\n        }\n    };\n\n    /**\n     * Update the agent assigned list of queues with (one or more) new joined statuses\n     * @param {array} newQueueStatusList List of queues with new joined status\n     */\n    const updateQueueList = (newQueueStatusList) => {\n        let updatedList = queueList;\n        updatedList = updatedList.map(queue => {\n            const foundElement = newQueueStatusList.filter(newQueueStatus =>\n                newQueueStatus.id == queue.id\n            );\n            if (foundElement.length == 1) {\n                queue.joined = foundElement[0].joined;\n            }\n            \n            return queue;\n        });\n\n        const relevantAgentMedia = filterApplicableMediaTypes(updatedList, configuredMediaTypes);\n        setRelevantMediaTypes(relevantAgentMedia);\n        setQueueList(updatedList);\n    }\n\n    useEffect(() => {\n        const loadGCXData = async() => {\n            try {\n                const usersMeData = await GCloud.getCurrentUser();\n                if (usersMeData.id) {\n                    logToConsole(debugMode, 'Home:Init:AgentID', usersMeData.id);\n                    setAgentId(usersMeData.id);\n    \n                    const userQueuesData = await GCloud.getUserQueues(usersMeData.id);\n                    logToConsole(debugMode, 'Home:Init:UserQueues', userQueuesData);\n                    setQueueList(userQueuesData);\n    \n                    logToConsole(debugMode, 'Home:Init:SupportedMediaTypes', supportedMediaTypes);\n                    setConfiguredMediaTypes(supportedMediaTypes);\n    \n                    const relevantAgentMedia = filterApplicableMediaTypes(userQueuesData, supportedMediaTypes);\n                    setRelevantMediaTypes(relevantAgentMedia);\n                    logToConsole(debugMode, 'Home:Init:RelevantMediaTypes', relevantAgentMedia);\n                }\n            }\n            catch (err) {\n                console.log(err);\n                setException(err);\n            }\n        }\n\n        logToConsole(debugMode, 'Home:Init - Initializing Media Switcher');\n        loadGCXData();\n    }, []);\n\n    return (\n        <div>\n            { exception && <GuxInlineAlertBeta accent='error'>{ exception.code } - {exception.message }</GuxInlineAlertBeta> }\n            <h1>Media Switcher</h1>\n            <GuxCardBeta className=\"toggle-area\">\n                { relevantMediaTypes.map(mediaType => (\n                    <GuxToggle\n                            key={ mediaType.mediaType }\n                            checked={ mediaType.joinStatus }\n                            id={ mediaType.mediaType }\n                            checkedLabel={ mediaType.label }\n                            uncheckedLabel={ mediaType.label }\n                            onCheck={ e => onToggleClick(e, mediaType.mediaType) } />\n                )) }\n            </GuxCardBeta>\n            <GuxTableBeta compact className=\"queue-status\" hidden={ (!debugMode) } >\n                <table slot=\"data\">\n                    <thead>\n                        <tr>\n                            <th>Queue</th>\n                            <th>Joined</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n                        { queueList.map(queue => (\n                            <tr key={ queue.id }>\n                                <td>{ queue.name }</td>\n                                <td>{ (queue.joined ? 'Yes' : 'No') }</td>\n                            </tr>\n                        )) }\n                    </tbody>\n                </table>\n            </GuxTableBeta>\n        </div>\n    );\n}\n\nexport default Home;"],"names":["registerElements","Home","queueList","setQueueList","React","configuredMediaTypes","setConfiguredMediaTypes","relevantMediaTypes","setRelevantMediaTypes","agentId","setAgentId","undefined","exception","setException","debugMode","useSelector","state","value","supportedMediaTypes","deploymentProperties","isCompliantMediaTypeQueue","queueName","queueNameParts","split","length","queueMediaType","toLowerCase","hasOwnProperty","filterApplicableMediaTypes","thisQueueList","thisSupportedMediaTypes","mediaTypes","idx","thisQueueName","name","thisQueueJoinStatus","joined","compliantMediaType","filter","mediaType","push","label","joinStatus","updateQueueStatus","async","newStatus","logToConsole","concat","newQueueStatusList","thisQueueId","id","GCloud","patchUserQueues","updateQueueList","err","updatedList","map","queue","foundElement","newQueueStatus","relevantAgentMedia","useEffect","usersMeData","getCurrentUser","userQueuesData","getUserQueues","console","log","loadGCXData","_jsxs","children","GuxInlineAlertBeta","accent","code","message","_jsx","GuxCardBeta","className","GuxToggle","checked","checkedLabel","uncheckedLabel","onCheck","e","onToggleClick","detail","GuxTableBeta","compact","hidden","slot"],"sourceRoot":""}