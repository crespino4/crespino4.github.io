{"version":3,"file":"static/js/5467.2bca15cb.chunk.js","mappings":"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","sources":["../node_modules/genesys-spark-components/dist/esm/floating-ui.dom.esm-483496c9.js"],"sourcesContent":["function getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min$1$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1$1 ? min$1$1 - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset + alignmentOffset\n      }\n    };\n  }\n});\n\nconst sides = ['top', 'right', 'bottom', 'left'];\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const axis = getMainAxisFromPlacement(placement);\n      const isXAxis = axis === 'x';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isXAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min$1(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min$1(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max$1(overflow.left, 0);\n        const xMax = max$1(overflow.right, 0);\n        const yMin = max$1(overflow.top, 0);\n        const yMax = max$1(overflow.bottom, 0);\n        if (isXAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return node instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const safari = isSafari();\n  const css = getComputedStyle$1(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !safari && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !safari && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction isSafari() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createEmptyCoords = v => ({\n  x: v,\n  y: v\n});\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createEmptyCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createEmptyCoords(0);\nfunction getVisualOffsets(element, isFixed, floatingOffsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (isFixed === void 0) {\n    isFixed = true;\n  }\n  if (!isSafari()) {\n    return noOffsets;\n  }\n  const win = element ? getWindow(element) : window;\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== win) {\n    return noOffsets;\n  }\n  return {\n    x: ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0,\n    y: ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createEmptyCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = getVisualOffsets(domElement, isFixedStrategy, offsetParent);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createEmptyCoords(1);\n  const offsets = createEmptyCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isSafari();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createEmptyCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createEmptyCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate as a, arrow as b, computePosition as c, size as d, flip as f, hide as h, offset as o, shift as s };\n"],"names":["getAlignment","placement","split","getLengthFromAxis","axis","getSide","getMainAxisFromPlacement","includes","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","x","width","commonY","y","height","mainAxis","length","commonAlign","isVertical","coords","evaluate","value","param","getSideObjectFromPadding","padding","_objectSpread","top","right","bottom","left","expandPaddingObject","rectToClientRect","rect","async","detectOverflow","state","options","_await$platform$isEle","platform","rects","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","min$1","Math","min","max$1","max","within","min$1$1","max$1$1","arrow","name","fn","arrowDimensions","getDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","center","offset","alignmentOffset","data","centerOffset","sides","oppositeSideMap","getOppositePlacement","replace","side","oppositeAlignmentMap","start","end","getOppositeAlignmentPlacement","alignment","flip","_middlewareData$flip","middlewareData","initialPlacement","_evaluate","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","detectOverflowOptions","_objectWithoutProperties","_excluded","isBasePlacement","isRTL","oppositePlacement","getExpandedPlacements","push","direction","list","isStart","lr","rl","tb","bt","getSideList","map","concat","getOppositeAxisPlacements","placements","overflow","overflows","overflowsData","main","cross","mainAlignmentSide","getAlignmentSides","every","_middlewareData$flip2","_overflowsData$filter","nextIndex","index","nextPlacement","reset","resetPlacement","filter","d","sort","a","b","_overflowsData$map$so","reduce","acc","getSideOffsets","isAnySideFullyClipped","some","hide","_evaluate2","_excluded2","offsets","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","diffCoords","mainAxisMulti","crossAxisMulti","rawValue","alignmentAxis","convertValueToCoords","shift","_evaluate3","limiter","_excluded3","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","size","_evaluate4","apply","_excluded4","isXAxis","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions","getWindow","node","_node$ownerDocument","ownerDocument","defaultView","window","getComputedStyle$1","getComputedStyle","isNode","Node","getNodeName","nodeName","toLowerCase","isHTMLElement","HTMLElement","Element","isShadowRoot","ShadowRoot","isOverflowElement","overflowX","overflowY","display","test","isTableElement","isContainingBlock","safari","isSafari","css","transform","perspective","containerType","backdropFilter","willChange","contain","CSS","supports","isLastTraversableNode","round","floor","createEmptyCoords","v","getCssDimensions","parseFloat","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","getBoundingClientRect","Number","isFinite","noOffsets","getVisualOffsets","isFixed","floatingOffsetParent","_win$visualViewport","_win$visualViewport2","win","visualViewport","offsetLeft","offsetTop","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","document","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","getParentNode","result","assignedSlot","parentNode","host","getNearestOverflowAncestor","body","getOverflowAncestors","scrollableAncestor","isBody","getClientRectFromClippingAncestor","clippingAncestor","html","clientWidth","clientHeight","visualViewportBased","getViewportRect","scroll","scrollWidth","scrollHeight","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","position","getTrueOffsetParent","polyfill","currentNode","getContainingBlock","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsetRect","clippingAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","set","getClippingElementAncestors","this","_c","firstClippingAncestor","clippingRect","accRect","getElementRects","getOffsetParentFn","getDimensionsFn","getClientRects","Array","from","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","forEach","addEventListener","passive","cleanupIo","onMove","timeoutId","io","root","cleanup","clearTimeout","disconnect","refresh","skip","threshold","rootMargin","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","setTimeout","e","observe","observeMove","frameId","reobserveFrame","resizeObserver","firstEntry","target","unobserve","cancelAnimationFrame","requestAnimationFrame","prevRefRect","frameLoop","nextRefRect","removeEventListener","computePosition","Map","mergedOptions","platformWithCache","config","middleware","validMiddleware","Boolean","statefulPlacement","resetCount","i","nextX","nextY","computePosition$1"],"sourceRoot":""}